# Lesson 17.5 The Service Worker Lifecycle

In the previous video, we observed 2 oddities. 
1. When we first created our service worker, it took 2 refreshes to see the result. 
2. And secondly, when we chagned the service worker, we didn't seem to pick up that change. 

The life cycle of service worker is one of the most complex parts. Once you get your head around this bit, the rest is easy. So we had our page open all ready, then we added code to register a service worker. Then we hit refresh. Hitting refresh spawned a new window client, then the request went off to the network, we got a response back, and the old window client went away. It might not seem like there's an overlap between the old page and the new page when you hit refresh, but there is. For example, if the response came back indicating that the browser should save the resource to disk via download dialog, then the old window would have stayed around. But in this case, the response was a page, so we got rid of the old one. From our page requests went out for our CSS images, but also a shiny new JavaScript, which registered the service worker. We didn't see request log from this page because the Service Worker only takes control of pages when they're loaded, and this page was loaded before the service worker existed. That means any additional requests this page makes will bypass the service worker. But then we refresh the page creating a new window client and becaue our service worker was up and running, it took control of it. Therefore, the request went to the Service Worker as did all of the subresources. So that explains why it took 2 refreshes to see logged requests. But what about when we change the thing we were logging yet still saw requests being logged, which was our old code. If a page loads via Service Worker, it will check for an update to the service worker in the background. And if it finds it has changed as in the resources and byte identical, it becomes the next version. But it doesn't take control, it waits. It won't take over until all pages using the current version are gone. This ensures there's only one version of your site running at a given time like native apps. Unfortunately, a refresh doesn't let the new version take over. This is due to the overlap between Window clients we saw earlier. There isn't actually a moment when the current active service worker isn't in use. For that to happen, this page needs to close or navigate to a page that isn't controlled by the Service Worker. When it does that, the new service worker takes over and future page loads will go through the new one. Let's put this knowledge to practice. So as before if I refresh the page, I'm still getting these old console logs. But if I navigate away then click back, the logs so difference. The new service worker is running. This update process may sound complicated at first but it's actually the same update process browsers such as Chrome use. Chrome will download the update in the background, but it won't take over until the browswer closes and opens again. It notifies the user that there's an update ready by changing the color of this icon. Later in the course we'll also notify users of updates to Wittr. When the browser refetches a service worker looking for updates, it will go through the browser cache. Because of this I strongly recommend keeping a cache time on your service worker short. 



- - -
Next up: [Quiz: Enaabling Service Worker Dev Tools](ND024_Part2_Lesson17_06.md) or return to [Table Of Contents](./ND024_TableOfContents.md)
